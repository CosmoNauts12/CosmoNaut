EPIC 1: Unified API Execution and Request Management

Objective
This epic enables developers to construct, execute, and inspect API requests within a unified debugging interface.

Why this Epic Exists
API execution is the core capability upon which tracing, workflows, automation, and replay are built.

User Story 1.1: API Request Creation
Client Perspective:
As a developer, I want to create configurable API requests so that I can test individual services.

Implementation Tasks:
FE: Build request editor UI for method, URL, headers, and body.
BE: Design request configuration schema.
QA: Validate request configuration before execution.

User Story 1.2: Execute Requests and View Responses
Client Perspective:
As a developer, I want to execute API requests and view responses to understand service behavior.

Implementation Tasks:
BE: Accept request configuration and execute via backend engine.
BE: Capture status, headers, and response body.
FE: Display formatted and raw responses.
QA: Test network failures and execution errors.

User Story 1.3: Multi-format Response Viewing
JSON viewer with syntax highlighting
Raw response display
HTTP status and header visibility

User Story 1.4: Execution Latency Tracking
Capture start and end timestamps
Compute execution duration
Display latency indicators

User Story 1.5: First-time User Onboarding
Guided walkthrough
Contextual UI highlights
Revisit help at any time

User Story 1.6 and 1.7: Execution History and Details
Store execution metadata
Display chronological history
Highlight failures
Filter by success or failure
